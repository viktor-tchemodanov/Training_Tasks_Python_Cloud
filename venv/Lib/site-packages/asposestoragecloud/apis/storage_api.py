# --------------------------------------------------------------------------------------------------------------------
# <copyright company="Aspose Pty Ltd" file="storage_api.py">
#   Copyright (c) 2015 Aspose.Storage for Cloud
# </copyright>
# <summary>
#   Permission is hereby granted, free of charge, to any person obtaining a copy
#  of this software and associated documentation files (the "Software"), to deal
#  in the Software without restriction, including without limitation the rights
#  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#  copies of the Software, and to permit persons to whom the Software is
#  furnished to do so, subject to the following conditions:
#
#  The above copyright notice and this permission notice shall be included in all
#  copies or substantial portions of the Software.
#
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#  SOFTWARE.
# </summary>
# --------------------------------------------------------------------------------------------------------------------
#


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..api_client import ApiClient


class StorageApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def delete_file(self, path, **kwargs):
        """
        Remove a specific file 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass is_async=True
        >>> thread = api.delete_file(path, is_async=True)
        >>> result = thread.get()

        :param is_async bool
        :param str path: Path of the file including file name and extension e.g. /Folder1/file.ext (required)
        :param str version_id: File's version
        :param str storage: User's storage name
        :return: RemoveFileResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('is_async'):
            return self.delete_file_with_http_info(path, **kwargs)
        else:
            (data) = self.delete_file_with_http_info(path, **kwargs)
            return data

    def delete_file_with_http_info(self, path, **kwargs):
        """
        Remove a specific file 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass is_async=True
        >>> thread = api.delete_file_with_http_info(path, is_async=True)
        >>> result = thread.get()

        :param is_async bool
        :param str path: Path of the file including file name and extension e.g. /Folder1/file.ext (required)
        :param str version_id: File's version
        :param str storage: User's storage name
        :return: RemoveFileResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'version_id', 'storage']
        all_params.append('is_async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params) or (params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `delete_file`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))
        if 'version_id' in params:
            query_params.append(('versionId', params['version_id']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/storage/file', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='RemoveFileResponse',
                                        auth_settings=auth_settings,
                                        is_async=params.get('is_async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_folder(self, path, **kwargs):
        """
        Remove a specific folder 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass is_async=True
        >>> thread = api.delete_folder(path, is_async=True)
        >>> result = thread.get()

        :param is_async bool
        :param str path: Folder path e.g. /Folder1 (required)
        :param str storage: User's storage name
        :param bool recursive: Remove recursivelly inner folder/files. If false and folder contains data than exception is raised.
        :return: RemoveFolderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('is_async'):
            return self.delete_folder_with_http_info(path, **kwargs)
        else:
            (data) = self.delete_folder_with_http_info(path, **kwargs)
            return data

    def delete_folder_with_http_info(self, path, **kwargs):
        """
        Remove a specific folder 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass is_async=True
        >>> thread = api.delete_folder_with_http_info(path, is_async=True)
        >>> result = thread.get()

        :param is_async bool
        :param str path: Folder path e.g. /Folder1 (required)
        :param str storage: User's storage name
        :param bool recursive: Remove recursivelly inner folder/files. If false and folder contains data than exception is raised.
        :return: RemoveFolderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'storage', 'recursive']
        all_params.append('is_async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params) or (params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `delete_folder`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/storage/folder', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='RemoveFolderResponse',
                                        auth_settings=auth_settings,
                                        is_async=params.get('is_async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_disc_usage(self, **kwargs):
        """
        Check the disk usage of the current account 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass is_async=True
        >>> thread = api.get_disc_usage(is_async=True)
        >>> result = thread.get()

        :param is_async bool
        :param str storage: User's storage name
        :return: DiscUsageResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('is_async'):
            return self.get_disc_usage_with_http_info(**kwargs)
        else:
            (data) = self.get_disc_usage_with_http_info(**kwargs)
            return data

    def get_disc_usage_with_http_info(self, **kwargs):
        """
        Check the disk usage of the current account 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass is_async=True
        >>> thread = api.get_disc_usage_with_http_info(is_async=True)
        >>> result = thread.get()

        :param is_async bool
        :param str storage: User's storage name
        :return: DiscUsageResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['storage']
        all_params.append('is_async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_disc_usage" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/storage/disc', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='DiscUsageResponse',
                                        auth_settings=auth_settings,
                                        is_async=params.get('is_async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_download(self, path, **kwargs):
        """
        Download a specific file 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass is_async=True
        >>> thread = api.get_download(path, is_async=True)
        >>> result = thread.get()

        :param is_async bool
        :param str path: Path of the file including the file name and extension e.g. /file.ext (required)
        :param str version_id: File's version
        :param str storage: User's storage name
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('is_async'):
            return self.get_download_with_http_info(path, **kwargs)
        else:
            (data) = self.get_download_with_http_info(path, **kwargs)
            return data

    def get_download_with_http_info(self, path, **kwargs):
        """
        Download a specific file 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass is_async=True
        >>> thread = api.get_download_with_http_info(path, is_async=True)
        >>> result = thread.get()

        :param is_async bool
        :param str path: Path of the file including the file name and extension e.g. /file.ext (required)
        :param str version_id: File's version
        :param str storage: User's storage name
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'version_id', 'storage']
        all_params.append('is_async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_download" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params) or (params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `get_download`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))
        if 'version_id' in params:
            query_params.append(('versionId', params['version_id']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['multipart/form-data'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/storage/file', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        is_async=params.get('is_async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_is_exist(self, path, **kwargs):
        """
        Check if a specific file or folder exists
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass is_async=True
        >>> thread = api.get_is_exist(path, is_async=True)
        >>> result = thread.get()

        :param is_async bool
        :param str path: File or folder path e.g. /file.ext or /Folder1 (required)
        :param str version_id: File's version
        :param str storage: User's storage name
        :return: FileExistResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('is_async'):
            return self.get_is_exist_with_http_info(path, **kwargs)
        else:
            (data) = self.get_is_exist_with_http_info(path, **kwargs)
            return data

    def get_is_exist_with_http_info(self, path, **kwargs):
        """
        Check if a specific file or folder exists
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass is_async=True
        >>> thread = api.get_is_exist_with_http_info(path, is_async=True)
        >>> result = thread.get()

        :param is_async bool
        :param str path: File or folder path e.g. /file.ext or /Folder1 (required)
        :param str version_id: File's version
        :param str storage: User's storage name
        :return: FileExistResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'version_id', 'storage']
        all_params.append('is_async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_is_exist" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params) or (params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `get_is_exist`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))
        if 'version_id' in params:
            query_params.append(('versionId', params['version_id']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/storage/exist', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FileExistResponse',
                                        auth_settings=auth_settings,
                                        is_async=params.get('is_async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_is_storage_exist(self, name, **kwargs):
        """
        Check if storage exists 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass is_async=True
        >>> thread = api.get_is_storage_exist(name, is_async=True)
        >>> result = thread.get()

        :param is_async bool
        :param str name: Storage name (required)
        :return: StorageExistResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('is_async'):
            return self.get_is_storage_exist_with_http_info(name, **kwargs)
        else:
            (data) = self.get_is_storage_exist_with_http_info(name, **kwargs)
            return data

    def get_is_storage_exist_with_http_info(self, name, **kwargs):
        """
        Check if storage exists 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass is_async=True
        >>> thread = api.get_is_storage_exist_with_http_info(name, is_async=True)
        >>> result = thread.get()

        :param is_async bool
        :param str name: Storage name (required)
        :return: StorageExistResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name']
        all_params.append('is_async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_is_storage_exist" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_is_storage_exist`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/storage/{name}/exist', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='StorageExistResponse',
                                        auth_settings=auth_settings,
                                        is_async=params.get('is_async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_list_file_versions(self, path, **kwargs):
        """
        Get the file's versions list 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass is_async=True
        >>> thread = api.get_list_file_versions(path, is_async=True)
        >>> result = thread.get()

        :param is_async bool
        :param str path: File path e.g. /file.ext or /Folder1/file.ext (required)
        :param str storage: User's storage name
        :return: FileVersionsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('is_async'):
            return self.get_list_file_versions_with_http_info(path, **kwargs)
        else:
            (data) = self.get_list_file_versions_with_http_info(path, **kwargs)
            return data

    def get_list_file_versions_with_http_info(self, path, **kwargs):
        """
        Get the file's versions list 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass is_async=True
        >>> thread = api.get_list_file_versions_with_http_info(path, is_async=True)
        >>> result = thread.get()

        :param is_async bool
        :param str path: File path e.g. /file.ext or /Folder1/file.ext (required)
        :param str storage: User's storage name
        :return: FileVersionsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'storage']
        all_params.append('is_async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_list_file_versions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params) or (params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `get_list_file_versions`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/storage/version', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FileVersionsResponse',
                                        auth_settings=auth_settings,
                                        is_async=params.get('is_async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_list_files(self, **kwargs):
        """
        Get the file listing of a specific folder 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass is_async=True
        >>> thread = api.get_list_files(is_async=True)
        >>> result = thread.get()

        :param is_async bool
        :param str path: Start with name of storage e.g. root folder '/'or some folder '/folder1/..'
        :param str storage: User's storage name
        :return: FilesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('is_async'):
            return self.get_list_files_with_http_info(**kwargs)
        else:
            (data) = self.get_list_files_with_http_info(**kwargs)
            return data

    def get_list_files_with_http_info(self, **kwargs):
        """
        Get the file listing of a specific folder 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass is_async=True
        >>> thread = api.get_list_files_with_http_info(is_async=True)
        >>> result = thread.get()

        :param is_async bool
        :param str path: Start with name of storage e.g. root folder '/'or some folder '/folder1/..'
        :param str storage: User's storage name
        :return: FilesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'storage']
        all_params.append('is_async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_list_files" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/storage/folder', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='FilesResponse',
                                        auth_settings=auth_settings,
                                        is_async=params.get('is_async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_move_file(self, src, dest, **kwargs):
        """
        Move a specific file 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass is_async=True
        >>> thread = api.post_move_file(src, dest, is_async=True)
        >>> result = thread.get()

        :param is_async bool
        :param str src: Source file path e.g. /fileSource.ext (required)
        :param str dest: Destination file path e.g. /fileDestination.ext (required)
        :param str version_id: Source file's version,
        :param str storage: User's source storage name
        :param str dest_storage: User's destination storage name
        :return: MoveFileResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('is_async'):
            return self.post_move_file_with_http_info(src, dest, **kwargs)
        else:
            (data) = self.post_move_file_with_http_info(src, dest, **kwargs)
            return data

    def post_move_file_with_http_info(self, src, dest, **kwargs):
        """
        Move a specific file 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass is_async=True
        >>> thread = api.post_move_file_with_http_info(src, dest, is_async=True)
        >>> result = thread.get()

        :param is_async bool
        :param str src: Source file path e.g. /fileSource.ext (required)
        :param str dest: Destination file path e.g. /fileDestination.ext (required)
        :param str version_id: Source file's version,
        :param str storage: User's source storage name
        :param str dest_storage: User's destination storage name
        :return: MoveFileResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['src', 'dest', 'version_id', 'storage', 'dest_storage']
        all_params.append('is_async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_move_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'src' is set
        if ('src' not in params) or (params['src'] is None):
            raise ValueError("Missing the required parameter `src` when calling `post_move_file`")
        # verify the required parameter 'dest' is set
        if ('dest' not in params) or (params['dest'] is None):
            raise ValueError("Missing the required parameter `dest` when calling `post_move_file`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'src' in params:
            query_params.append(('src', params['src']))
        if 'dest' in params:
            query_params.append(('dest', params['dest']))
        if 'version_id' in params:
            query_params.append(('versionId', params['version_id']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'dest_storage' in params:
            query_params.append(('destStorage', params['dest_storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/storage/file', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='MoveFileResponse',
                                        auth_settings=auth_settings,
                                        is_async=params.get('is_async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_move_folder(self, src, dest, **kwargs):
        """
        Move a specific folder 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass is_async=True
        >>> thread = api.post_move_folder(src, dest, is_async=True)
        >>> result = thread.get()

        :param is_async bool
        :param str src: Source folder path e.g. /Folder1 (required)
        :param str dest: Destination folder path e.g. /Folder2 (required)
        :param str storage: User's source storage name
        :param str dest_storage: User's destination storage name
        :return: MoveFolderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('is_async'):
            return self.post_move_folder_with_http_info(src, dest, **kwargs)
        else:
            (data) = self.post_move_folder_with_http_info(src, dest, **kwargs)
            return data

    def post_move_folder_with_http_info(self, src, dest, **kwargs):
        """
        Move a specific folder 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass is_async=True
        >>> thread = api.post_move_folder_with_http_info(src, dest, is_async=True)
        >>> result = thread.get()

        :param is_async bool
        :param str src: Source folder path e.g. /Folder1 (required)
        :param str dest: Destination folder path e.g. /Folder2 (required)
        :param str storage: User's source storage name
        :param str dest_storage: User's destination storage name
        :return: MoveFolderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['src', 'dest', 'storage', 'dest_storage']
        all_params.append('is_async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_move_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'src' is set
        if ('src' not in params) or (params['src'] is None):
            raise ValueError("Missing the required parameter `src` when calling `post_move_folder`")
        # verify the required parameter 'dest' is set
        if ('dest' not in params) or (params['dest'] is None):
            raise ValueError("Missing the required parameter `dest` when calling `post_move_folder`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'src' in params:
            query_params.append(('src', params['src']))
        if 'dest' in params:
            query_params.append(('dest', params['dest']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'dest_storage' in params:
            query_params.append(('destStorage', params['dest_storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/storage/folder', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='MoveFolderResponse',
                                        auth_settings=auth_settings,
                                        is_async=params.get('is_async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_create(self, path, file, **kwargs):
        """
        Upload a specific file 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass is_async=True
        >>> thread = api.put_create(path, file, is_async=True)
        >>> result = thread.get()

        :param is_async bool
        :param str path: Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext (required)
        :param file file: File to upload (required)
        :param str version_id: Source file's version
        :param str storage: User's storage name
        :return: UploadResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('is_async'):
            return self.put_create_with_http_info(path, file, **kwargs)
        else:
            (data) = self.put_create_with_http_info(path, file, **kwargs)
            return data

    def put_create_with_http_info(self, path, fileData, **kwargs):
        """
        Upload a specific file 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass is_async=True
        >>> thread = api.put_create_with_http_info(path, fileData, is_async=True)
        >>> result = thread.get()

        :param is_async bool
        :param str path: Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext (required)
        :param IOBase fileData: File Data to upload (required)
        :param str version_id: Source file's version
        :param str storage: User's storage name
        :return: UploadResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'fileData', 'version_id', 'storage']
        all_params.append('is_async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params) or (params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `put_create`")
        # verify the required parameter 'fileData' is set
        if ('fileData' not in params) or (params['fileData'] is None):
            raise ValueError("Missing the required parameter `fileData` when calling `put_create`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))
        if 'version_id' in params:
            query_params.append(('versionId', params['version_id']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = fileData
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/storage/file', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='UploadResponse',
                                        auth_settings=auth_settings,
                                        is_async=params.get('is_async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_create_folder(self, path, **kwargs):
        """
        Create the folder 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass is_async=True
        >>> thread = api.put_create_folder(path, is_async=True)
        >>> result = thread.get()

        :param is_async bool
        :param str path: Target folder's path e.g. Folder1/Folder2/. The folders will be created recursively (required)
        :param str storage: User's source storage name
        :param str dest_storage: User's destination storage name
        :return: CreateFolderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('is_async'):
            return self.put_create_folder_with_http_info(path, **kwargs)
        else:
            (data) = self.put_create_folder_with_http_info(path, **kwargs)
            return data

    def put_create_folder_with_http_info(self, path, **kwargs):
        """
        Create the folder 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass is_async=True
        >>> thread = api.put_create_folder_with_http_info(path, is_async=True)
        >>> result = thread.get()

        :param is_async bool
        :param str path: Target folder's path e.g. Folder1/Folder2/. The folders will be created recursively (required)
        :param str storage: User's source storage name
        :param str dest_storage: User's destination storage name
        :return: CreateFolderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'storage', 'dest_storage']
        all_params.append('is_async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_create_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params) or (params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `put_create_folder`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'dest_storage' in params:
            query_params.append(('destStorage', params['dest_storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/storage/folder', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='CreateFolderResponse',
                                        auth_settings=auth_settings,
                                        is_async=params.get('is_async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_copy(self, path, newdest, **kwargs):
        """
        Copy a specific file 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass is_async=True
        >>> thread = api.put_copy(path, newdest, is_async=True)
        >>> result = thread.get()

        :param is_async bool
        :param str path: Source file's path. Sample: '/Folder 1/file.ext' or '/Bucket/Folder 1/file.ext' (required)
        :param str newdest: Destination file path (required)
        :param str version_id: Source file's version
        :param str storage: User's source storage name
        :param str dest_storage: User's destination storage name
        :return: CopyFileResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('is_async'):
            return self.put_copy_with_http_info(path, newdest, **kwargs)
        else:
            (data) = self.put_copy_with_http_info(path, newdest, **kwargs)
            return data

    def put_copy_with_http_info(self, path, newdest, **kwargs):
        """
        Copy a specific file 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass is_async=True
        >>> thread = api.put_copy_with_http_info(path, newdest, is_async=True)
        >>> result = thread.get()

        :param is_async bool
        :param str path: Source file's path. Sample: '/Folder 1/file.ext' or '/Bucket/Folder 1/file.ext' (required)
        :param str newdest: Destination file path (required)
        :param str version_id: Source file's version
        :param str storage: User's source storage name
        :param str dest_storage: User's destination storage name
        :return: CopyFileResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'newdest', 'version_id', 'storage', 'dest_storage']
        all_params.append('is_async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_copy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params) or (params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `put_copy`")
        # verify the required parameter 'newdest' is set
        if ('newdest' not in params) or (params['newdest'] is None):
            raise ValueError("Missing the required parameter `newdest` when calling `put_copy`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))
        if 'newdest' in params:
            query_params.append(('newdest', params['newdest']))
        if 'version_id' in params:
            query_params.append(('versionId', params['version_id']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'dest_storage' in params:
            query_params.append(('destStorage', params['dest_storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/storage/file', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='CopyFileResponse',
                                        auth_settings=auth_settings,
                                        is_async=params.get('is_async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_copy_folder(self, path, newdest, **kwargs):
        """
        Copy a folder 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass is_async=True
        >>> thread = api.put_copy_folder(path, newdest, is_async=True)
        >>> result = thread.get()

        :param is_async bool
        :param str path: Source folder path e.g. /Folder1 (required)
        :param str newdest: Destination folder path e.g. /Folder2 (required)
        :param str storage: User's source storage name
        :param str dest_storage: User's destination storage name
        :return: CreateFolderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('is_async'):
            return self.put_copy_folder_with_http_info(path, newdest, **kwargs)
        else:
            (data) = self.put_copy_folder_with_http_info(path, newdest, **kwargs)
            return data

    def put_copy_folder_with_http_info(self, path, newdest, **kwargs):
        """
        Copy a folder 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass is_async=True
        >>> thread = api.put_copy_folder_with_http_info(path, newdest, is_async=True)
        >>> result = thread.get()

        :param is_async bool
        :param str path: Source folder path e.g. /Folder1 (required)
        :param str newdest: Destination folder path e.g. /Folder2 (required)
        :param str storage: User's source storage name
        :param str dest_storage: User's destination storage name
        :return: CreateFolderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'newdest', 'storage', 'dest_storage']
        all_params.append('is_async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_copy_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params) or (params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `put_copy_folder`")
        # verify the required parameter 'newdest' is set
        if ('newdest' not in params) or (params['newdest'] is None):
            raise ValueError("Missing the required parameter `newdest` when calling `put_copy_folder`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))
        if 'newdest' in params:
            query_params.append(('newdest', params['newdest']))
        if 'storage' in params:
            query_params.append(('storage', params['storage']))
        if 'dest_storage' in params:
            query_params.append(('destStorage', params['dest_storage']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/storage/folder', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='CreateFolderResponse',
                                        auth_settings=auth_settings,
                                        is_async=params.get('is_async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
